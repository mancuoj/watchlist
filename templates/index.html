{% extends 'base.html' %}

{% block content %}
<!-- 在 <form> 标签里使用 method 属性将提交表单数据的 HTTP 请求方法指定为 POST -->
<!-- 默认使用 GET 方法将表单数据通过 URL 提交，容易导致数据泄露，而且不适用于包含大量数据的情况 -->
<!-- GET 请求用来获取资源，而 POST 则用来创建 / 更新资源。我们访问一个链接时会发送 GET 请求，而提交表单通常会发送 POST 请求 -->
<!-- <input> 元素必须要指定 name 属性，否则无法提交数据，在服务器端，我们也需要通过这个 name 属性值来获取对应字段的数据 -->
<!-- 当表单中的提交按钮被按下，浏览器会创建一个新的请求，默认发往当前 URL（在 <form> 元素使用 action 属性可以自定义目标 URL） -->
<form class="add-form" method="post">
    <input type="text" name="title" autocomplete="off" placeholder="电影名称" required>
    <input type="text" name="year" autocomplete="off" placeholder="电影年份" required>
    <input class="add-btn" type="submit" name="submit" value="添加">
</form>

<ul class="movie-list">
    {% for movie in movies %}
    <li>
        <span class="movie-desc">
            {{ movie.title }} - {{ movie.year }}
        </span>
        <a class="btn edit-btn" href="{{ url_for('edit', movie_id=movie.id) }}">修改</a>
        <form class="del-form" method="post" action="{{ url_for('delete', movie_id=movie.id) }}">
            <!-- CSRF 是一种常见的攻击手段。以我们的删除表单为例，某恶意网站的页面中内嵌了一段代码，访问时会自动发送一个删除某个电影条目的 POST 请求到我们的程序 -->
            <!-- 如果我们访问了这个恶意网站，就会导致电影条目被删除，因为我们的程序没法分辨请求发自哪里 -->
            <!-- 解决方法通常是在表单里添加一个包含随机字符串的隐藏字段，同时在 Cookie 中也创建一个同样的随机字符串，在提交时通过对比两个值是否一致来判断是否是用户自己发送的请求。在我们的程序中没有实现 CSRF 保护 -->
            <!-- 删除按钮的行内 JavaScript 代码改为事件监听函数，写到单独的 JavaScript 文件里 -->
            <!-- 也可以使用 JavaScript 来监听点击删除按钮的动作，并发送删除条目的 POST 请求，这样删除按钮就可以使用普通 <a> 标签（CSRF 令牌存储在元素属性里），而不用创建表单元素 -->
            <input class="btn del-btn" type="submit" name="delete" value="删除" onclick="return confirm('确定删除？')">
        </form>
        <a class="btn douban" target="_blank"
            href="https://search.douban.com/movie/subject_search?search_text={{ movie.title }}">
            豆
        </a>
    </li>
    {% endfor %}
</ul>
{% endblock content %}